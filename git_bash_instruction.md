![Logo](GIT.jpg)
# Работа с Git     

> Git  — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано (https://ru.wikipedia.org/wiki/Git#История).

## 1. Проверка наличия установленного Git 
Выполнить команду ```git --version``` 
Если  Git установлен появиться сообщение с информацией о версии программы. Иначе появится сообщение об ошибке.

## 2. Установка Git 

Загружаем последнюю версию с сайта https://git-scm.com/download/win
устанавливаем настройки по умолчанию. 


## 3. Настройка Git

При первом использовании Git необходимо представиться. Для необходимо в терменале ввести две команды: 
```
git config --global username "Имя пользователя"
gif config --global useremail "почта@почта.com" 
```

## 4. Инициализация репозитория
Получить репозиторий можно двуми способами:
* В терминале переходим к папке, в которой хотим создать репозитрий. Выполняем команду ```git init```

* Клонировать существующий репозиторий git  из любого места. Сделать это можно так  ```git clone <адрес репозитория>```.

## 5. Определение состояния репозитория 

Команда ```git status``` показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. 

## 6. Сделать файл отслеживаемым

 Команда ```git add``` добавляет файл в отслеживаемые и позволяет коммитить все нужное в репозиторий командой commit.

 ## 7. Совершение коммита

 Команда ```git commit``` создает непосредственно сам коммит. 
 * Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. 
 * Команда ```git commit --amend -m <новый комментарий>``` перезапишет сообщение последнего коммита.

 ## 8. Запись изменений в репозиторий

Kаждый файл в рабочей папке (репозитории) может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и без контроля (неотслеживаемые).

Отслеживаемые файлы могут быть неизмененными, измененными или подготовленными к коммиту.

## 9. Просмотр истории Коммитов

Просматривать изменения, внесённые в репозиторий, можно с помощью команды ```git log```. Она отображает список последних коммитов в порядке выполнения.

Добавив флаг -p, можно подробно изучить изменения, внесённые в каждый файл.

### 9.1. Варианты команды ```git log```
1. добавление параметра --oneline показывает только хэш коммита и commit message;
2. добавление  параметра --graph показывает ASCII-граф истории ветвлений и слияний рядом с выводом лога;
3. добавление параметра --word-diff показывает изменения на уровне слов;
4. добавление параметров --after и --before задают начальную и конечную даты коммитов.

## 10. Перемещение между сохранениями 

Команда ```git checkout``` используется для переключения и выгрузки содержимого в рабочую директорию, команда может работать с тремя различными объектами:
* файлами 
* коммитами 
* ветками.

Команду ```git checkout``` можно использовать для просмотра старых коммитов. 

## 11. Просмотр изменений в репозитории

Можно использовать команду ```git diff```. Возможно показать изменения между рабочим деревом и индексом, изменения между двумя деревьями, изменения, возникающие в результате слияния, изменения между двумя объектами  или изменения между двумя файлами на диске.

## 12. Откат последнего коммита

Откатить последний коммит можно с помощью команды ```git revert```. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.

### Разница между revert и reset

Команда ```git revert``` отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда ```git reset```.

У команды __revert__ есть преимущества по сравнению с __reset__: 
* она не меняет историю проекта и производит операцию, безопасную для коммитов. 
* объектом команды  __revert__ выступает конкретный коммит, созданный в любой момент истории, а __reset__ всегда берёт за точку отсчёта текущий коммит. 

Так, если нужно отменить старый коммит с помощью __git reset__, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. 

## 13.  Работа с ветками в Git

### 13.1. Создание новой ветки и переход в неё

Создать новую ветку можно с помощью параметра ```git branch new_branch_name```, указав имя ветки.

Для автоматического перехода нужно добавить флаг -b и параметр __checkout__.

### 13.2. Просмотр списка веток

Просматривать полный список веток можно, используя команду ```git branch```. Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.

Вывести список *удалённых веток* можно с помощью команды ```git branch -a```.

### 13.3. Удаление ветки

Удалить ветку можно командой ```git branch -d existing_branch_name``` с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. 

Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

Для принудительного удаления ветки используется ```git branch -D existing_branch_name``` флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

### 13.4. Слияние двух веток

Объединить две ветки можно командой ```git merge existing_branch_name``` с указанием имени ветки. Команда объединит указанную ветку с основной.

### 13.5. Конфликты слияния в Git

Когда Git не может выполнить автоматическое слияние, поскольку изменения происходят в одном блоке, он указывает конфликтующие блоки специальными символами. 

Все между ```<<<<<<<``` и ```=======``` являeтся локальными изменениями. Эти изменения еще не внесены в репозиторий. Все строки между ```=======``` и ```>>>>>>>``` являются изменениями из  другой ветки. Теперь необходимо изучить эти два блока и принять решение.

При возникновении конфликта можно:
* сохранить изменения из сливаемой ветки и удалить из текущей;
* удалить изменения из сливаемой ветки и сохранить из текущей;
* сохранить изменения из сливаемой и текущей веток;
* удалить изменения из сливаемой и текущей веток.

После внесения изменений необходимо убедиться, что ни один из символов, указывающих на конфликт, не существует __<<<<<<<, =======, >>>>>>>__ в файле. 

После этого необходимо выполнить следующие действия: 
* внести изменения __git add__
* зафиксировать изменения с сообщением __git commit -m "Message"__.

## 14. Игнорирование файлов 

>Игнорируемый файл — файл, явным образом помеченный для Git как файл, который необходимо игнорировать. 

Игнорируемые файлы — это, как правило, артефакты сборки и файлы, генерируемые машиной из исходных файлов в вашем репозитории, либо файлы, которые по какой-либо иной причине не должны попадать в коммиты (например, *.png, *.jpg). 

Игнорируемые файлы отслеживаются в специальном файле __.gitignore__, который регистрируется в корневом каталоге репозитория. 

В Git нет специальной команды для указания игнорируемых файлов: вместо этого необходимо вручную отредактировать файл __.gitignore__, чтобы указать в нем новые файлы, которые должны быть проигнорированы.

 Файлы __.gitignore__ содержат шаблоны, которые сопоставляются с именами файлов в репозитории для определения необходимости игнорировать эти файлы.

 ### 14.1. Игнорирование ранее закоммиченного файла

  Чтобы игнорировать файл, для которого ранее был сделан коммит, необходимо удалить этот файл из репозитория, а затем добавить для него правило в __.gitignore__.  
  
  Kоманда ```git rm --cached ``` удалит этот файл из репозитория, но оставит его в рабочем каталоге как игнорируемый файл. 
  
  Исключение параметра ```--cached``` удалит файл как из репозитория, так и из локальной файловой системы.

  ### 14.2. Коммит игнорируемого файла

 Можно принудительно сделать коммит игнорируемого файла в репозиторий с помощью команды ```git add -f``` (или --force).

 ## 15. Работа с удаленными репозиториями

 > Удалённые репозитории представляют собой версии какого-то проекта, сохранённые в интернете или ещё где-то в сети. 
 Копировать удаленный репозиторий на свой ПК можно с помощью команды ```git clone```. Когда репозиторий клонируется, команда ```git clone``` автоматически добавляет этот удалённый репозиторий под именем __«origin»__.

 ### 15.1. Просмотр удалённых репозиториев

 Просмотреть список настроенных удалённых репозиториев можно с помощью команды ```git remote```. Она выводит названия доступных удалённых репозиториев. 

### 15.2. Добавление удалённых репозиториев
 Добавить удалённый репозиторий и присвоить ему имя  можно с помощью команды ```git remote add <shortname> <url>```.

 ### 15.3. Получение изменений из удалённого репозитория

 Команды  ```git pull``` и ```git fetch``` можно рассматривать команды загрузки (скачивания):

 
 * Использование команды ```git pull``` позволяет получить изменения из удалённой ветки и слить их со своей текущей.  По умолчанию команда ```git clone```  настраивает вашу локальную ветку __master__ на отслеживание удалённой ветки на сервере, с которого клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение ```git pull```, как правило, извлекает данные с сервера, с которого изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.
* Использование команды ```git fetch origin``` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Однако команда ```git fetch``` забирает данные в локальный репозиторий, но не сливает их и не модифицирует. Необходимо дополнительно слить эти данные с вашими.

### 15.4. Отправка изменений в удаленный репозиторий
 Команда ```git push``` используется для выгрузки содержимого локального репозитория в удаленный репозиторий. Она позволяет передать коммиты из локального репозитория в удаленный. Использование коменды ```git push``` требует авторизации при первом использовании в том месте, где находится удаленный репозиторий, например на GitHub.





![Logo](fox.png)
![Logo](KL.png)

